// Generated by CoffeeScript 1.10.0
var game;

game = {
  boardWidth: 300,
  boardHeight: 300,
  boardSpacing: 30,
  gameInterval: 100,
  playerHeight: 5,
  playerDepth: 1,
  camAngle: 0,
  camSmoothness: 5
};

Number.prototype.mod = function(n) {
  return (this % n + n) % n;
};

game.initGame = function() {
  game.initBoard();
  game.bind();
  game.getCanvas();
  return window.setInterval(function() {
    return game.updateGame();
  }, game.gameInterval);
};

game.initBoard = function() {
  var col, i, j, line, ref, ref1;
  game.board = [];
  for (line = i = 0, ref = game.boardHeight; 0 <= ref ? i <= ref : i >= ref; line = 0 <= ref ? ++i : --i) {
    game.board.push([]);
    for (col = j = 0, ref1 = game.boardWidth; 0 <= ref1 ? j <= ref1 : j >= ref1; col = 0 <= ref1 ? ++j : --j) {
      game.board[line].push(null);
    }
  }
  game.players = [];
  return game.players.push({
    id: 0,
    name: 'GonÃ§alo',
    score: 0,
    orientation: 'right',
    position: [1, 1],
    lastPosition: null,
    color: 0xff0000
  });
};

game.detectCollision = function(pos, dir) {
  switch (dir) {
    case 'up':
      if (pos[1] - 1 < 0 || game.board[pos[1] - 1][pos[0]] !== null) {
        return true;
      }
      break;
    case 'down':
      if (pos[1] + 1 >= game.boardHeight || game.board[pos[1] + 1][pos[0]] !== null) {
        return true;
      }
      break;
    case 'left':
      if (pos[0] - 1 < 0 || game.board[pos[1]][pos[0] - 1] !== null) {
        return true;
      }
      break;
    case 'right':
      if (pos[0] + 1 >= game.boardWidth || game.board[pos[1]][pos[0] + 1] !== null) {
        return true;
      }
  }
};

game.playerLost = function(player) {
  var col, colIndex, i, j, len, len1, line, lineIndex, ref;
  player.lost = true;
  ref = game.board;
  for (lineIndex = i = 0, len = ref.length; i < len; lineIndex = ++i) {
    line = ref[lineIndex];
    for (colIndex = j = 0, len1 = line.length; j < len1; colIndex = ++j) {
      col = line[colIndex];
      if (col === player.id) {
        game.board[lineIndex][colIndex] = null;
      }
    }
  }
  game.destroyPlayerObject(player);
  return game.initBoard();
};

game.updatePlayer = function(player) {
  if (player.lost) {
    return;
  }
  switch (player.orientation) {
    case 'up':
      game.board[player.position[1] - 1][player.position[0]] = player.id;
      player.position[1]--;
      break;
    case 'down':
      game.board[player.position[1] + 1][player.position[0]] = player.id;
      player.position[1]++;
      break;
    case 'left':
      game.board[player.position[1]][player.position[0] - 1] = player.id;
      player.position[0]--;
      break;
    case 'right':
      game.board[player.position[1]][player.position[0] + 1] = player.id;
      player.position[0]++;
  }
  player.lastOrientation = player.orientation;
  return game.renderPlayer(player);
};

game.playerMove = function(player, dir) {
  var newDir;
  if (!player) {
    player = game.players[0];
  }
  if (dir === 'right' && player.lastOrientation === 'right') {
    newDir = 'down';
  }
  if (dir === 'left' && player.lastOrientation === 'right') {
    newDir = 'up';
  }
  if (dir === 'right' && player.lastOrientation === 'left') {
    newDir = 'up';
  }
  if (dir === 'left' && player.lastOrientation === 'left') {
    newDir = 'down';
  }
  if (dir === 'right' && player.lastOrientation === 'down') {
    newDir = 'left';
  }
  if (dir === 'left' && player.lastOrientation === 'down') {
    newDir = 'right';
  }
  if (dir === 'right' && player.lastOrientation === 'up') {
    newDir = 'right';
  }
  if (dir === 'left' && player.lastOrientation === 'up') {
    newDir = 'left';
  }
  return player.orientation = newDir;
};

game.bind = function() {
  document.addEventListener('keydown', function(e) {
    if (e.keyCode === 65 || e.keyCode === 37) {
      game.playerMove(false, 'left');
    }
    if (e.keyCode === 68 || e.keyCode === 39) {
      return game.playerMove(false, 'right');
    }
  }, true);
};

game.getPlayerById = function(id) {
  var i, len, player, ref, results;
  ref = game.players;
  results = [];
  for (i = 0, len = ref.length; i < len; i++) {
    player = ref[i];
    if (id === player.id) {
      results.push(player);
    } else {
      results.push(void 0);
    }
  }
  return results;
};

game.updateGame = function() {
  var i, len, player, ref, results;
  ref = game.players;
  results = [];
  for (i = 0, len = ref.length; i < len; i++) {
    player = ref[i];
    if (game.detectCollision(player.position, player.orientation)) {
      game.playerLost(player);
    }
    results.push(game.updatePlayer(player));
  }
  return results;
};

game.updateCamera = function() {
  var camStep, desiredAngle, difference, player, playerX, playerY;
  player = game.getPlayerById(0)[0];
  if (player._rawPos) {
    playerX = player._rawPos[0];
    playerY = player._rawPos[1];
  }
  game.camera.position.y = 150;
  game.camera.position.z = playerY - 100 * Math.cos(game.camAngle) - 100 * Math.sin(game.camAngle);
  game.camera.position.x = playerX + 100 * Math.sin(game.camAngle) - 100 * Math.cos(game.camAngle);
  if (player.orientation === 'right') {
    desiredAngle = 0;
  } else if (player.orientation === 'left') {
    desiredAngle = Math.PI;
  } else if (player.orientation === 'down') {
    desiredAngle = Math.PI / 2;
  } else if (player.orientation === 'up') {
    desiredAngle = 3 * Math.PI / 2;
  }
  difference = Math.abs(desiredAngle - game.camAngle);
  if (difference < 2 * Math.PI - difference) {
    camStep = difference / game.camSmoothness;
  } else {
    camStep = -(2 * Math.PI - difference) / game.camSmoothness;
  }
  if (desiredAngle - game.camAngle < 0) {
    camStep = -camStep;
  }
  if (player._rawPos) {
    game.camera.lookAt(new THREE.Vector3(player._rawPos[0], 0, player._rawPos[1]));
  }
  return game.camAngle = (game.camAngle + camStep).mod(2 * Math.PI);
};

game.renderPlayer = function(player) {
  return game.createPlayerObject(player);
};

game.getCanvas = function() {
  var boardLineMaterial, colIndex, geometry, i, j, line, material, ref, ref1, rowIndex;
  game.scene = new THREE.Scene();
  game.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  game.renderer = new THREE.WebGLRenderer();
  game.renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(game.renderer.domElement);
  geometry = new THREE.BoxGeometry(game.boardWidth * game.boardSpacing, 0, game.boardHeight * game.boardSpacing);
  material = new THREE.MeshBasicMaterial({
    color: 0x000000
  });
  game.floor = new THREE.Mesh(geometry, material);
  game.scene.add(game.floor);
  boardLineMaterial = new THREE.LineBasicMaterial({
    color: 0x333333
  });
  for (colIndex = i = 0, ref = game.boardWidth; 0 <= ref ? i <= ref : i >= ref; colIndex = 0 <= ref ? ++i : --i) {
    geometry = new THREE.Geometry();
    geometry.vertices.push(new THREE.Vector3(game.boardSpacing * colIndex - (game.boardSpacing * game.boardWidth / 2), 1, -(game.boardSpacing * game.boardHeight / 2)), new THREE.Vector3(game.boardSpacing * colIndex - (game.boardSpacing * game.boardWidth / 2), 1, game.boardSpacing * game.boardHeight / 2));
    line = new THREE.Line(geometry, boardLineMaterial);
    game.scene.add(line);
  }
  for (rowIndex = j = 0, ref1 = game.boardHeight; 0 <= ref1 ? j <= ref1 : j >= ref1; rowIndex = 0 <= ref1 ? ++j : --j) {
    geometry = new THREE.Geometry();
    geometry.vertices.push(new THREE.Vector3(-(game.boardSpacing * game.boardWidth / 2), 1, game.boardSpacing * rowIndex - (game.boardSpacing * game.boardHeight / 2)), new THREE.Vector3(game.boardSpacing * game.boardWidth / 2, 1, game.boardSpacing * rowIndex - (game.boardSpacing * game.boardHeight / 2)));
    line = new THREE.Line(geometry, boardLineMaterial);
    game.scene.add(line);
  }
  game.camera.position.z = 10;
  game.camera.position.x = 0;
  game.camera.position.y = 50;
  game.camera.lookAt(new THREE.Vector3(0, 0, 0));
  game.executeSequence();
  return game.createPlayerObject(0);
};

game.createPlayerObject = function(player) {
  var animStep, geometry, material, obj, orientation, playerAnim;
  if (!player) {
    return;
  }
  geometry = new THREE.BoxGeometry(game.boardSpacing, game.playerHeight, game.playerDepth);
  material = new THREE.MeshBasicMaterial({
    color: player.color
  });
  obj = new THREE.Mesh(geometry, material);
  if (!player._object) {
    player._object = [];
  }
  if (player.orientation === 'up' || player.orientation === 'down') {
    obj.rotateOnAxis(new THREE.Vector3(0, 1, 0), Math.PI / 2);
  }
  obj.position.x = player.position[0] * game.boardSpacing - (game.boardWidth / 2) * game.boardSpacing;
  obj.position.y = game.playerHeight / 2;
  obj.position.z = player.position[1] * game.boardSpacing - (game.boardHeight / 2) * game.boardSpacing;
  switch (player.orientation) {
    case 'up':
      obj.position.z = obj.position.z + game.boardSpacing;
      geometry.applyMatrix(new THREE.Matrix4().makeTranslation(game.boardSpacing / 2, 0, 0));
      break;
    case 'left':
      obj.position.x = obj.position.x + game.boardSpacing;
      geometry.applyMatrix(new THREE.Matrix4().makeTranslation(-game.boardSpacing / 2, 0, 0));
      break;
    case 'right':
      obj.position.x = obj.position.x - game.boardSpacing;
      geometry.applyMatrix(new THREE.Matrix4().makeTranslation(game.boardSpacing / 2, 0, 0));
      break;
    case 'down':
      obj.position.z = obj.position.z - game.boardSpacing;
      geometry.applyMatrix(new THREE.Matrix4().makeTranslation(-game.boardSpacing / 2, 0, 0));
  }
  obj.scale.x = 0.000001;
  player._object.push(obj);
  game.scene.add(obj);
  animStep = 0;
  orientation = player.orientation;
  return playerAnim = window.setInterval(function() {
    animStep = animStep + 0.1;
    obj.scale.x = animStep;
    player._rawPos = [obj.position.x, obj.position.z];
    switch (orientation) {
      case 'up':
        player._rawPos[1] -= animStep * game.boardSpacing;
        break;
      case 'left':
        player._rawPos[0] -= animStep * game.boardSpacing;
        break;
      case 'right':
        player._rawPos[0] += animStep * game.boardSpacing;
        break;
      case 'down':
        player._rawPos[1] += animStep * game.boardSpacing;
    }
    console.log(player._rawPos[0] + ' ' + player._rawPos[1]);
    if (animStep >= 0.99) {
      return window.clearInterval(playerAnim);
    }
  }, game.gameInterval / 10);
};

game.destroyPlayerObject = function(player) {
  var i, len, obj, ref, results;
  if (!player) {
    return;
  }
  ref = player._object;
  results = [];
  for (i = 0, len = ref.length; i < len; i++) {
    obj = ref[i];
    results.push(game.scene.remove(obj));
  }
  return results;
};

game.executeSequence = function() {
  requestAnimationFrame(game.executeSequence);
  game.updateCamera();
  return game.renderer.render(game.scene, game.camera);
};

game.initGame();
